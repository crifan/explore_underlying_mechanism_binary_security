# SEHOP

* `SEHOP`=`Structured Exception Handler Overwrite Protection`=`结构化异常处理覆盖保护`
  * 背景
    * `SEH攻击`：指通过栈溢出或者其他漏洞，使用精心构造的数据覆盖结构化异常处理链表上面的某个节点或者多个节点，从而控制EIP（控制程序执行流程）
    * `SEHOP`：是是微软针对这种攻击提出的一种安全防护方案
  * 详解
    * 微软最开始提供这个功能是在2009年，支持的系统包括Windows Vista Service Pack 1、 Windows 7、Windows Server 2008 和 Windows Server 2008 R2，以及它们的后续版本。它是以一种SEH扩展的方式提供的，通过对程序中使用的SEH结构进行一些安全检测，来判断应用程序是否受到了SEH攻击。SEHOP的核心是检测程序栈中的所有SEH结构链表，特别是最后一个SEH结构，它拥有一个特殊的异常处理函数指针，指向的是一个位于NTDLL中的函数。异常处理时，由系统接管分发异常处理，因此上面描述的检测方案完全可以由系统独立来完成，正因为SEH的这种与应用程序的无关性，因此应用程序不用做任何改变，你只需要确认你的系统开启了SEHOP即可。在Windows Server 2008 和 Windows Server 2008 R2下SEHOP默认是开启的，而在Windows Vista Service Pack 1、 Windows 7下默认则是关闭的
    * SEHOP的任务就是检查这条S.E.H链的完整性，在程序转入异常处理前SEHOP会检查S.E.H链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果是，则说明这条S.E.H链没有被破坏，程序可以去执行当前的异常的处理函数；如果检测到最后一个异常处理函数不是终极BOSS，则说明S.E.H链被破坏，可能发生了S.E.H覆盖攻击，程序将不会去执行当前的异常处理函数。
    * 攻击时将S.E.H结构中的异常处理函数地址覆盖为跳板指令地址，跳板指令根据实际情况进行选择。当程序出现异常的时候，系统会从S.E.H链中取出异常处理函数来处理异常，异常处理函数的指针已经被覆盖，程序的流程就会被劫持，在经过一系列跳转后转入Shellcode执行。
    * 由于覆盖异常处理函数指针时同时覆盖了指向下一异常处理结构的指针，这样的话，S.E.H链就会被破坏，从而被SEHOP机制检测到。
    * 作为对SafeSEH强有力的补充，SEHOP检查是在SafeSEH的RtlIsValidHandler函数校验前进行的，也就是说利用攻击加载模块之外的地址、堆地址和未启用SafeSEH模块的方法都行不通了，必须要考虑其它的方法
  * 突破SEHOP方法
    * 不去攻击S.E.H，而是攻击函数返回地址或虚函数等
    * 利用未启用SEHOP的模块
    * 伪造S.E.H链
